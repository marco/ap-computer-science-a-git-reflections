What happens when you initialize a repository? Why do you need to do it?

    When you initialize a repository, the `.git` directory is created in the
    current repository. Essentially, this enables all of the Git functionality
    to be used within that repository. This is because it is the `.git`
    directory that houses the storage mechanism for the Git history. Without
    the `.git` directory, Git commands would not work because there would be
    no location to store the history.

    Additionally, initialization is especially important when collaborating.
    Git functionality is very valuable when working together because it
    shows clear changes between versions, which ensures quality code. Git
    repositories can also be shared on websites like GitHub, enabling for
    easier communication and collaboration. initialization is required for
    these benefits.

How is the staging area different from the working directory and the
repository? What value do you think it offers?

    The staging area can serve as a "middleground" for code that you might want
    to commit, but don't want to commit yet. When using `git add`, code is
    added to the staging area before committing. You must then call
    `git commit` afterwards in order to actually commit these files.

    One benefit that this provides is that it furthers Git's premise of only
    committing quality code. By giving programmers a way to stage code before
    committing, they can check that the code follows proper guidelines by
    using `git diff --cached`.

    Additionally, the staging area is helpful when making multiple changes at
    once. By using a staging area, a programmer can ensure that functioning
    code will not be lost, without committing, while still working on a new
    feature. For example, if two changes have to be made to one file, a
    programmer could make one change, stage it, and then keep working on the
    second in order to ensure that the first change will not accidentally be
    broken. (If it was, then they could revert to the staged changes using
    `git checkout`.) In summary, the staging area allows for code safety and
    code quality before committing.

How can you use the staging area to make sure you have one commit per logical
change?

    A programmer can use the staging area to ensure that they only have one
    commit per logical change by checking the staged diff before committing.
    Since a programmer can use `git diff --cached` to check the staged changes,
    they can easily look over the new code and ensure that only one logical
    change has been made.

    Making only one logical change per commit is important, because it allows
    for easier reviewing of the Git history, and can make finding bugs and
    creating solutions simpler. By committing only one logical change at a
    time, a programmer can see easily what each commit does and when a feature
    was added.
